import time
import threading

from bluetoothapi import BluetoothAPI
from serialapi import SerialAPI
import RPi.GPIO as GPIO
import atexit
import socket
from imutils.video import VideoStream
import imagezmq
import numpy as np

class Multithreader:
    
    def __init__(self):
        self.bluetoothapi = BluetoothAPI()
        self.serialapi = SerialAPI()
    
    #Function to start all the threads
    def initialize_processes(self):
        print("[Main] Attempting to initialize multithreader...")
        #Connect the different components
        self.serialapi.connect()
        self.bluetoothapi.connect()

        #Run the multithreading
        self.read_bluetooth_process = threading.Thread(target=self.read_bluetooth)
        self.read_image_process = threading.Thread(target=self.read_image)

        self.read_bluetooth_process.start()
        self.read_image_process.start()
        print("[Main] Initialized multithreader successfully")

        self.read_bluetooth_process.join()
        self.read_image_process.join()

    #Function to take picture, send to the image server and handle result
    def read_image(self):
        global takePic
        global queue
        count = 0 
        sender = imagezmq.ImageSender(connect_to="tcp://192.168.36.11:50000")
        rpi_name = socket.gethostname()
        picam = VideoStream(usePiCamera=True).start()
        print("[Main] Video stream started")
        time.sleep(1.0)
        while count < 2:
            if takePic:
                print("Taking Picture")
                image = picam.read()
                result = sender.send_image(rpi_name, image)
                print("[Main] Received result:", result)
                if b'38' in result:
                    print("Putting R result in the queue")
                    queue.append('R')
                    takePic = False
                    count+= 1
                elif b'39' in result:
                    print("Putting L result in the queue")
                    queue.append('L')
                    takePic = False
                    count+=1

    #Function to read messages for bluetooth and stop the function after start is read
    def read_bluetooth(self):
        global takePic
        global queue
        while True:
            message = self.bluetoothapi.read()
            if message is not None and len(message) > 0:               
                print("[Main] Message recieved from bluetooth", message)
                try:
                  if b'START' in message:
                      #Tell STM to start moving
                      takePic = True
                      self.serialapi.write(str.encode("X100"))
                      self.serialapi.read()
                      self.serialapi.write(str.encode("W100"))
                      break
                except:
                      print("[ERROR] Invalid message from bluetooth")
        message = self.serialapi.read()           
        print("[Main] Message recieved from STM", message)
        while len(queue) == 0:
            print("[Main] Awaiting image from server")
            time.sleep(0.5)
        message = queue.pop()
        message = message+"100"
        print(f"[Main] Sending {message} to STM")
        self.serialapi.write(str.encode(message))
        print(f"[Main] Sent {message} to STM")
        ack = self.serialapi.read()
        print(f"[Main] Received {ack} from STM (P)")

        print("[Main] Starting to spam pictures")
        takePic = True
        while len(queue)==0:
            print("[Main] Awaiting image from server")
            time.sleep(0.5)
        message = queue.pop()
        ack = self.serialapi.read()
        print(f"Read {ack} from stm (D2)")
        print(f"[Main] Sending {message} to STM")
        self.serialapi.write(str.encode("X100"))
        self.serialapi.read()
        message = message+"200"
        self.serialapi.write(str.encode(message))
        print(f"[Main] Sent {message} to STM")
        self.send_empty_image()
        print("[Main] Sent empty image")
        ack = self.serialapi.read()
        print(f"[Main] Received {ack} from STM")
        exit()

    #Function to send empty image to image server to stitch the image
    def send_empty_image(self):
        print("[Image] Attempting to connect to Image Server...")
        sender = imagezmq.ImageSender(connect_to="tcp://192.168.36.11:50000")
        print('[Image] Telling Image to stitch..')
        image = np.eye(640)
        reply = sender.send_image("done", image)
        print(f"[Image] Acknowledgement received {reply}")
                     
    #Clean up operation after we exit the programme
    def clean_up(self):
        GPIO.cleanup()


if __name__ == "__main__":
    takePic = False
    readSTM = False
    queue = []
    currentObs = 1

    #Running the programme
    mt = Multithreader()
    atexit.register(mt.clean_up)

    time.sleep(1)

    mt.initialize_processes()


